\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\renewcommand{\footnotesize}{\fontsize{8pt}{10pt}\selectfont} %mmm: diminui o tamanho da fonte de footnote
\usepackage{titling} % Customizing the title section
\setlength{\droptitle}{-6\baselineskip} % Move the title up

\usepackage{geometry}
\geometry{left=2cm, right=2cm, bottom=2.5cm, top=3cm} %diminuir a margem

\usepackage{natbib}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{setspace}
% COLOR %Para escrever observações de cores diferentes
\usepackage{color}
\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\seunome}[1]{\textcolor[rgb]{0.29,0.77,0.83}{#1}}
\newcommand{\nome}[1]{\textcolor[RGB]{138,43,226}{#1}}

\singlespacing

\newcommand{\pyline}[1]{\mintinline{python}|#1|}
\newcommand{\yell}[1]{{\color{blue} [#1]}}
\newcommand{\tom}[1]{\yell{#1 --tom}}

\title{Integrating Proof Production in Cylindrical Algebraic Decomposition}
\author{Anonymous}
\date{}

\begin{document}

\maketitle

\vspace{-20pt}
\section{Introduction}
\subsection{Context}

% Motivation

\qquad One of the most fundamental properties of any software program is its correctness with respect
to a given specification. This ensures that the program behaves as expected for all possible inputs.
For example, a sorting algorithm is considered correct if it returns a sorted permutation of any input
list. Similarly, specifications can be defined for far more complex systems, such as airplane
controllers or medical devices, in which correctness is necessary for guaranteeing its safety.
Therefore, the problem of verifying if a piece of software is correct is critical in the modern world.

Indeed, there exists a number of examples of malfunctioning software causing irreparable damage
that fortify the importance of verification: the explosion of the rocket Ariane 5 in 1996, caused by
a incorrect conversion between numerical values; the faulty operation of Knight Capital's trading algorithm,
leading to a debt of 440 milion dollars for the company in 2012; the deaths of at least 3 people caused by
the Therac-25 radiation therapy machine, which was attributed to the existence of race conditions in its
software.

% Formal methods

There are a variety of techniques to obtain correctness evidence for a
software. The most common one is the development of tests. Besides being easy to write
an efficient set of tests, there are many types of bugs that can be
discovered with its execution. In fact, this approach is enough for a large
amount of problems that are solved by software engineering.
However, tests can't guarantee that a program doesn't have flaws, since the number of
valid inputs is almost always exceedingly large, or infinite, and, as explained, this guarantee
is crucial for the development of software with critical responsibility.
In this context, a promising alternative is to carry out the formal verification
of the system, that is, the rigorous checking that it meets the predetermined specification.
This is achieved by reasoning symbolically about the code, which enables validating the specification
for all possible inputs at once.

% Maybe we should give a separate paragraph for automated reasoning, where we can introduce SMT, proof assistants.
% I feel that it will be necessary to explain the benefits of proof production. Also we will have to go more in detail
% About SMT later

Automatic theorem provers (ATPs) are systems in which the user enters as input a conjecture written in
a logical
formalism and the system responds with ``yes'' or ``no'', depending on whether that conjecture is true or
not (or ``unknown'' if it could not get to a conclusion).
It is possible to use an ATP to formally verify a piece of software by enconding the behavior of the system
and the desired property as a logical formula. Indeed, this is one of the main use cases for these tools.
%
However, one important concern over ATPs is whether or not they are, themselves, correct. This is crucial
in the context of formal verification since any mistake in their logic or implementation will invalidate any
correctness result they produce. Unfortunately, since these solvers are usually highly complex,
it is remarkably hard to prove that they are completely correct. Moreover, even if a proof is concluded,
any modification in the system will require its correctness to be proven again. One alternative that has been
gaining attention in recent years~\cite{generatingProofs, proofsInSmt} is to modify the system to produce
proofs on the fly of its results. This means that, in addition to outputting ``yes'' or ``no'', they will
also provide a detailed trace that explains how they derived that conclusion. These traces can be
checked independently by a third-party software, transferring the need in trusting the solver (which often
comprises hundreds of thousands of lines of code) in a need to trust the proof checker (which usually is
written in a few thousands of lines of code).
%
A second application of this modification is to provide a powerful mean for debugging the solver.
In many cases~\cite{generatingProofs}, if there is a bug in the ATP, it will produce an incorrect
proof and this proof will give hints to the developers about where the bug probably is.
%
Finally, a third application of instrumenting solvers to produce proofs is exporting them to
other contexts where they are highly valuable, such as in proof assistants.
%
Proof assistants are interactive systems in which the user states a theorem and manually constructs
a proof for it. The system verifies each step of the proof, providing feedback to the user, and only
accepts the proof if all steps are correct \tom{Maybe I should add some applications of proof assistants?
i.e.~formalization of math and formal verification of software}. Similar to proof checkers, proof
assistants are easier to trust because the part of their code responsible for checking proofs is
relatively small. However, they are more difficult to use, as the user must construct the proof
manually. Additionally, these proofs need to be much more detailed than traditional pen-and-paper proofs
since they must be automatically verified by a computer.
%
One notable way of improving the usability of proof assistants is to connect them with an ATP,
making it possible for the user to discharge some proof obligations to the automatic solver.
This approach has been proven to be successful in the past~\cite{coq2, reconstruct}, but it
only works with ATPs that are capable of producing proofs.
%
All these applications goes to show the importance of proofs for automatic theorem provers.

There are many classes of ATPs. This project will be mainly concerned with Satisfiability Modulo Theory (SMT)
solvers~\cite{smtbook}. Satisfiability Modulo Thoeries is an extension of the Boolean Satisfiability Problem (SAT), in
which the underlying logic system is First-Order Logic. Additionally, a set of theories is included, that is,
a set of domains over which the input terms can be defined (as opposed to just Booleans), as well as operators
from these domains. For instance, the following is a valid formula in the context of SMT: $x \ge 0 \wedge x < 1
\wedge f(x) \neq f(0)$, where $x$ is an integer and $f$ is a function from integers to integers. SMT solvers are
systems specialized in determining automatically whether such formulas are satisfiable. Internally, an SMT solver
consists of a solver for SAT and multiple domain-specific solvers, one for each domain of interest. The SMT solver
is implemented in a way that all of these modules can operate independently from each other~\cite{cdcl_t}.


\tom{From here is just a draft}
To enable an SMT solver to generate proofs, it is sufficient to instrument each of its internal solvers to produce proofs.
There has been a lot of effort in the past (citations) to add this capability to the solvers. While we undertand
how to do this for most of them, we currently don't have a good solution when it comes to non-linear arithmetic.
There have been versions of incomplete algorithms that produce proofs for this domain (citations), but the Cylindrical Algebraic
Decomposition, which is the main complete algorithm does not have that.




% One pervasive task among automatic theorem provers is to decide
% automatically whether a given arithmetic formula containing free variables ranging over integer or
% real numbers is a tautology (i.e.\ true regardless of the values assigned to the free variables).
% The inherent difficulty of this problem varies depending on the characteristics of the formula:
% if the problem is linear (i.e.\ does not contain multiplication of free variables), then
% it can be solved in polynomial time if all variables range over the real numbers~\cite{Kha79}, and it
% is NP-complete~\cite{Kar72} otherwise; when non-linear restrictions are introduced, the complexity increases
% dramatically, as it requires an algorithm with doubly-exponential ($\mathcal{O}(2^{2^{n}})$) time complexity
% to solve it if all variables range over reals~\cite{computerAlgebraBook},
% and it is undecidable otherwise~\cite{integerUndec}.


% Quantifiers?

% Proofs
% Improve reliability
% Find bugs on solvers
% Maybe talk about the benefit described in Leo's paper


\subsection{Goals}



\section{Related Work}



\section{Methodology}

% \qquad In order to implement the API between SMT solvers and Lean, several steps
% must be completed. First of all, it's necessary to understand how to use
% metaprogramming\cite{metaprog} in Lean, since this tool will be implemented in the language of
% the assistant itself. Then, each theory in SMT will be matched with a native
% structure of Lean. This matching will be used in the translation process. Also,
% it's necessary to define what are the possible ways to communicate the Lean
% language to the SMT language. It shall be decided whether SMT-LIB will be
% used, or an intermediate language through PySMT or SMT-Switch, or another
% method. Once that is done, the tools that currently do the same integration with
% other assistants will be studied. In particular, the way they translate the
% theories in SMT to their particular language. Finally, a prototype will be
% implemented and tested. For that, a set of theorems to be used as test cases will
% be defined. It's also important to decide what metrics of the tool must be
% measured, and use theorems that will highlight those aspects. All the obtained results
% will be reported in a scientific article. One last
% important point is that the team that currently leads the development of Lean
% will participate in the project and all the decisions that were mentioned will be
% taken together with it.

% \newpage

\section{Schedule}
% \qquad The following table shows the plan of courses to be taken in each
% semester:

% \begin{table}[!htbp]
% \caption[Schedule]{Initial Schedule of Classes}
% \vspace{5pt}
% \centering
% \renewcommand{\arraystretch}{1.2}
% \begin{tabular}{@{}p{2cm}p{14cm}@{}}
% \toprule
% \textbf{Semester} & \textbf{Classes} \\
% \midrule
% 2021/02
%    & DCC874: Language Theory \\
%    & DCC865: Algorithm Design and Analysis\\
% \hline
% 2022/01
%    & DCC831: Formal Methods \\
%    & DCC880: Formal Semantics \\
% \hline
% 2022/02 & DCC831: Informational Theory \\
%   & DCC831: Theoretical Cryptography \\

%  \bottomrule
% \end{tabular}
% \end{table}

% \, The next table presents the planning of activities that will be
% performed per semester related to the
% project development:

% \begin{table}[!htbp]
% \caption[Schedule]{Initial Schedule of the Project}
% \vspace{5pt}
% \centering
% \renewcommand{\arraystretch}{1.2}
% \begin{tabular}{@{}p{2cm}p{14cm}@{}}
% \toprule
% \textbf{Semester} & \textbf{Goals} \\
% \midrule
%  2021/02 & Understand the operation of existing tools that integrate SMT solvers
%     with proof assistants. \\
% \hline
%  2022/01
%    & Start the implementation of the tool. \\
% \hline
%   2022/02 & Finish the implementation of the tool and start the writing of the final
%     report. \\
% \hline
%   2023/01 & Finish the writing of the final report. \\

%  \bottomrule
% \end{tabular}
% \end{table}


%\begin{figure}[h!]
%\centering
%\includegraphics[scale=1.7]{universe}
%\caption{The Universe}
%\label{fig:universe}
%\end{figure}

\renewcommand{\refname}{References}
\bibliographystyle{plain}
\bibliography{references}
\end{document}
