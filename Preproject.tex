\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\renewcommand{\footnotesize}{\fontsize{8pt}{10pt}\selectfont} %mmm: diminui o tamanho da fonte de footnote
\usepackage{titling} % Customizing the title section
\setlength{\droptitle}{-6\baselineskip} % Move the title up

\usepackage{geometry}
\geometry{left=2cm, right=2cm, bottom=2.5cm, top=3cm} %diminuir a margem

\usepackage{natbib}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{setspace}
% COLOR %Para escrever observações de cores diferentes
\usepackage{color}
\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\seunome}[1]{\textcolor[rgb]{0.29,0.77,0.83}{#1}}
\newcommand{\nome}[1]{\textcolor[RGB]{138,43,226}{#1}}

\singlespacing

\newcommand{\pyline}[1]{\mintinline{python}|#1|}
\newcommand{\yell}[1]{{\color{blue} [#1]}}
\newcommand{\tom}[1]{\yell{#1 --tom}}

\title{Integrating Proof Production in Cylindrical Algebraic Decomposition}
\author{Anonymous}
\date{}

\begin{document}

\maketitle

\vspace{-20pt}
\section{Introduction}
\subsection{Context}

% Motivation

\qquad One of the most fundamental properties of any software program is its correctness with respect
to a given specification. This ensures that the program behaves as expected for all possible inputs.
For example, a sorting algorithm is considered correct if it returns a sorted permutation of any input
list. Similarly, specifications can be defined for far more complex systems, such as airplane
controllers or medical devices, in which correctness is necessary for guaranteeing its safety.
Therefore, the problem of verifying if a piece of software is correct is critical in the modern world.

Indeed, there exists a number of examples of malfunctioning software causing irreparable damage
that fortify the importance of verification: the explosion of the rocket Ariane 5 in 1996, caused by
a incorrect conversion between numerical values; the faulty operation of Knight Capital's trading algorithm,
leading to a debt of 440 milion dollars for the company in 2012; the deaths of at least 3 people caused by
the Therac-25 radiation therapy machine, which was attributed to the existence of race conditions in its
software.

% Formal methods

There are a variety of techniques to obtain correctness evidence for a
software. The most common one is the development of tests. Besides being easy to write
an efficient set of tests, there are many types of bugs that can be
discovered with its execution. In fact, this approach is enough for a large
amount of problems that are solved by software engineering.
However, tests can't guarantee that a program doesn't have flaws, since the number of
valid inputs is almost always exceedingly large, or infinite, and, as explained, this guarantee
is crucial for the development of software with critical responsibility.
In this context, a promising alternative is to carry out the formal verification
of the system, that is, the rigorous checking that it meets the predetermined specification.
This is achieved by reasoning symbolically about the code, which enables validating the specification
for all possible inputs at once.

% Maybe we should give a separate paragraph for automated reasoning, where we can introduce SMT, proof assistants.
% I feel that it will be necessary to explain the benefits of proof production. Also we will have to go more in detail
% About SMT later

Automated reasoning is an area of computer science that involves the development of tools and techniques aiming
to promote the cooperation between humans and computers to prove or disprove conjectures written in a logical
formalism. Among other use cases, these tools have been widely used to aid in the process of formally verifying software.
%
However, one important concern over them is whether or not they are, themselves, correct. This is crucial
in the context of formal verification since any mistake in their logic or implementation will invalidate any
correctness result they produce. Unfortunately, since these logical solvers are usually highly complex,
it is remarkably hard to prove that they are completely correct. Moreover, even if a proof is concluded,
any modification in the system will require its correctness to be proven again. One alternative that has been
gaining attention in recent years~\cite{generatingProofs, proofsInSmt} is to modify the system to produce
proofs on the fly of its results. This means that, in addition to outputting ``yes'' or ``no'', they will
also provide a detailed trace that explains how they derived that conclusion. These traces can potentially be
checked independently by a third-party software, transferring the need in trusting the solver (which often
comprises hundreds of thousands of lines of code) in a need to trust the proof checker (which usually is
written in a few thousands of lines of code).
%
Instrumenting solvers to produce proofs bring other valuable benefits, such as exporting these proofs
to be used in the context of proof assistants~\cite{coq2, reconstruct}.


\tom{I probably want to rewrite this sentence} A third application of producing proofs is to provide a
powerful mean for debugging the solver~\cite{generatingProofs}.
%


One pervasive task among automated reasoning tools is to decide
automatically whether a given arithmetic formula containing free variables ranging over integer or
real numbers is a tautology (i.e.\ true regardless of the values assigned to the free variables).
The inherent difficulty of this problem varies depending on the characteristics of the formula:
if the problem is linear (i.e.\ does not contain multiplication of free variables), then
it can be solved in polynomial time if all variables range over the real numbers~\cite{Kha79}, and it
is NP-complete~\cite{Kar72} otherwise; when non-linear restrictions are introduced, the complexity increases
dramatically, as it requires an algorithm with doubly-exponential ($\mathcal{O}(2^{2^{n}})$) time complexity
to solve it if all variables range over reals~\cite{computerAlgebraBook},
and it is undecidable otherwise~\cite{integerUndec}.


% Quantifiers?

% Proofs
% Improve reliability
% Find bugs on solvers
% Maybe talk about the benefit described in Leo's paper


\subsection{Goals}



\section{Related Work}



\section{Methodology}

% \qquad In order to implement the API between SMT solvers and Lean, several steps
% must be completed. First of all, it's necessary to understand how to use
% metaprogramming\cite{metaprog} in Lean, since this tool will be implemented in the language of
% the assistant itself. Then, each theory in SMT will be matched with a native
% structure of Lean. This matching will be used in the translation process. Also,
% it's necessary to define what are the possible ways to communicate the Lean
% language to the SMT language. It shall be decided whether SMT-LIB will be
% used, or an intermediate language through PySMT or SMT-Switch, or another
% method. Once that is done, the tools that currently do the same integration with
% other assistants will be studied. In particular, the way they translate the
% theories in SMT to their particular language. Finally, a prototype will be
% implemented and tested. For that, a set of theorems to be used as test cases will
% be defined. It's also important to decide what metrics of the tool must be
% measured, and use theorems that will highlight those aspects. All the obtained results
% will be reported in a scientific article. One last
% important point is that the team that currently leads the development of Lean
% will participate in the project and all the decisions that were mentioned will be
% taken together with it.

% \newpage

\section{Schedule}
% \qquad The following table shows the plan of courses to be taken in each
% semester:

% \begin{table}[!htbp]
% \caption[Schedule]{Initial Schedule of Classes}
% \vspace{5pt}
% \centering
% \renewcommand{\arraystretch}{1.2}
% \begin{tabular}{@{}p{2cm}p{14cm}@{}}
% \toprule
% \textbf{Semester} & \textbf{Classes} \\
% \midrule
% 2021/02
%    & DCC874: Language Theory \\
%    & DCC865: Algorithm Design and Analysis\\
% \hline
% 2022/01
%    & DCC831: Formal Methods \\
%    & DCC880: Formal Semantics \\
% \hline
% 2022/02 & DCC831: Informational Theory \\
%   & DCC831: Theoretical Cryptography \\

%  \bottomrule
% \end{tabular}
% \end{table}

% \, The next table presents the planning of activities that will be
% performed per semester related to the
% project development:

% \begin{table}[!htbp]
% \caption[Schedule]{Initial Schedule of the Project}
% \vspace{5pt}
% \centering
% \renewcommand{\arraystretch}{1.2}
% \begin{tabular}{@{}p{2cm}p{14cm}@{}}
% \toprule
% \textbf{Semester} & \textbf{Goals} \\
% \midrule
%  2021/02 & Understand the operation of existing tools that integrate SMT solvers
%     with proof assistants. \\
% \hline
%  2022/01
%    & Start the implementation of the tool. \\
% \hline
%   2022/02 & Finish the implementation of the tool and start the writing of the final
%     report. \\
% \hline
%   2023/01 & Finish the writing of the final report. \\

%  \bottomrule
% \end{tabular}
% \end{table}


%\begin{figure}[h!]
%\centering
%\includegraphics[scale=1.7]{universe}
%\caption{The Universe}
%\label{fig:universe}
%\end{figure}

\renewcommand{\refname}{References}
\bibliographystyle{plain}
\bibliography{references}
\end{document}
