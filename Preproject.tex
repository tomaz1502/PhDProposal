\documentclass[a4paper, 12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\renewcommand{\footnotesize}{\fontsize{8pt}{10pt}\selectfont} %mmm: diminui o tamanho da fonte de footnote
\usepackage{titling} % Customizing the title section
\setlength{\droptitle}{-6\baselineskip} % Move the title up

\usepackage{geometry}
\geometry{left=2cm, right=2cm, bottom=2.5cm, top=3cm} %diminuir a margem

\usepackage{natbib}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{setspace}
% COLOR %Para escrever observações de cores diferentes
\usepackage{color}
\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\seunome}[1]{\textcolor[rgb]{0.29,0.77,0.83}{#1}}
\newcommand{\nome}[1]{\textcolor[RGB]{138,43,226}{#1}}

\singlespacing

\newcommand{\pyline}[1]{\mintinline{python}|#1|}
\newcommand{\yell}[1]{{\color{blue} [#1]}}
\newcommand{\tom}[1]{\yell{#1 --tom}}

\title{Integrating Proof Production in Cylindrical Algebraic Decomposition}
\author{Anonymous}
\date{}

\begin{document}

\maketitle

\vspace{-20pt}
\section{Introduction}
\subsection{Context}

% Motivation

\qquad One of the most fundamental properties of any software program is its correctness with respect
to a given specification. This ensures that the program behaves as expected for all possible inputs.
For example, one possible specification for a sorting routine is that its output list is always sorted.
Thus, it will be considered correct if this property is respected for any input list it receives.
Similarly, specifications can be defined for far more complex systems, such as airplane
controllers or medical devices, in which correctness is necessary for guaranteeing its safety.
Therefore, the problem of \textit{verifying} if a piece of software is correct is critical in the modern world.

Indeed, there exists a number of examples of malfunctioning software causing irreparable damage
that fortify the importance of verification: the explosion of the rocket Ariane 5 in 1996, caused by
a incorrect conversion between numerical values; the faulty operation of Knight Capital's trading algorithm,
leading to a debt of 440 milion dollars for the company in 2012; the deaths of at least 3 people caused by
the Therac-25 radiation therapy machine, which was attributed to the existence of race conditions in its
software.

% Formal methods

There are a variety of techniques to obtain correctness evidence for a
software. The most common one is the development of tests. Besides being easy to write
an efficient set of tests, there are many types of bugs that can be
discovered with its execution. In fact, this approach is enough for a large
amount of problems that are solved by software engineering.
However, in general, tests can't guarantee that a program doesn't have flaws, since the number of
valid inputs is almost always exceedingly large, or infinite.
In this context, a promising alternative is to carry out the formal verification
of the system, that is, the rigorous checking that it meets the predetermined specification.
This is achieved by reasoning symbolically about the code, which enables validating the specification
for all possible inputs at once.

% Maybe we should give a separate paragraph for automated reasoning, where we can introduce SMT, proof assistants.
% I feel that it will be necessary to explain the benefits of proof production. Also we will have to go more in detail
% About SMT later

Automatic theorem provers (ATPs) are systems in which the user enters as input a conjecture written in
a logical
formalism and the system responds with ``yes'' or ``no'', depending on whether that conjecture is true or
not (or ``unknown'' if it could not get to a conclusion).
One remarkable use case of ATPs is to formally verify software systems by encoding
their behavior and the desired property as logical formulas. More concretely,
one can write a formula that expresses the idea ``there exists some configuration
that forces my system into a given bad state'' and send it to the ATP. If it responds
with ``yes'', it will usually also present the undesired configuration. Otherwise,
if it responds with ``no'', the user can be sure that the bad state will never occur,
assuming he trusts the ATP.

\subsubsection{SMT Solvers}

There are many classes of automatic theorem provers. Even though the techniques we aim
to develop could potentially serve any of them, this project will be mainly concerned with
their integration with Satisfiability Modulo Theory (SMT) solvers~\cite{smtbook}.
Satisfiability Modulo Thoeries is an extension of the Boolean Satisfiability Problem (SAT),
in which the underlying logic system is First-Order Logic. Additionally, a set of theories
is included, that is, a set of domains over which the input terms can be defined (as opposed
to just Booleans), as well as operators from these domains. For instance, the following is
a valid SMT formula: $x \ge 0 \wedge x < 1 \wedge f(x) \neq f(0)$, where $x$ is an integer
and $f$ is a function from integers to integers.
%
SMT solvers are systems specialized in determining automatically whether such formulas are satisfiable.

\subsection{Generating Proofs}
One important concern over ATPs is whether or not they are, themselves, correct. This is crucial
in the context of formal verification since any mistake in their logic or implementation will invalidate any
correctness result they produce. Unfortunately, since these solvers are usually highly complex,
it is remarkably hard to prove that they are completely correct. Moreover, even if a proof is concluded,
any modification in the system will require its correctness to be proven again. One alternative that has been
gaining attention in recent years~\cite{generatingProofs, proofsInSmt} is to modify the system to produce
proofs certificates on the fly of its results. This means that, in addition to outputting ``yes'' or ``no'', they will
also provide a witness that serves as a precise logical argument supporting their conclusion. These witnesses can be
checked independently by a third-party software, transferring the need in trusting the solver (which often
comprises hundreds of thousands of lines of code) in a need to trust the proof checker (which usually is
written in a few thousands of lines of code).

A second application of this modification is to provide a powerful mean for debugging the solver.
In many cases~\cite{generatingProofs}, if there is a bug in the ATP, it will produce an incorrect
proof and this proof will give hints to the developers about where the bug probably is.
In addition to that, the process of doing this modification forces
the developers to understand deeply the implementation of the solver.

Finally, a third application of instrumenting solvers to produce proofs is exporting them to
other contexts where they are highly valuable, such as in proof assistants.
%
Proof assistants are interactive systems in which the user states a theorem and manually constructs
a proof for it. The system verifies each step of the proof, providing feedback to the user, and only
accepts the proof if all steps are correct.
%
Similar to proof checkers, proof assistants are easier to trust because the part of their code
responsible for checking proofs is relatively small.
%
One remarkable use case of interactive provers is the formalization of mathematics.
Since the formalization of the Four Color Theorem~\cite{fctCoq} in a proof assistant called Coq,
mathematicians have used more and more these tools to increase the level of certainty
they have in their results, and also, to facilitate large scale collaboration between them.
More recently, in 2022, the fields-medalist Peter Scholze announced that he and his collaborators
completed the formalization of Perfectoid Spaces~\cite{scholze}, a result that lies in the
cutting edge of research in mathematics, using another proof assistant.
%
However, these tools are more difficult to use, as the user must construct their proofs
manually. Additionally, these proofs need to be much more detailed than traditional pen-and-paper proofs,
since they must be automatically verified by a computer.
%
One notable way of improving the usability of proof assistants is to connect them with an ATP,
making it possible for the user to discharge some proof obligations to the automatic solver.
This approach has been proven to be successful in the past~\cite{coq2, reconstruct}, but it
only works with ATPs that are capable of producing proofs.
%
All these applications goes to show the importance of proofs for automatic theorem provers.


\subsection{Solving Arithmetic Constraints}

The problem of solving a set of arithmetic constraints (i.e.\ expressions that set conditions
on the values of variables according to arithmetic relationships and logical operators) is
pervasive when trying to prove conjectures automatically. More generally, these expressions
can also contain quantifiers binding the variables. In this case, solving the problem requires
performing \textit{quantifier elimination}, that is, finding a new formula without quantifiers
that is equivalent to the original one. Since this kind of problem is ubiquitous in theorem
proving, it is crucial for automated theorem provers to implement efficient methods for solving it.

% The process of automatically proving theorems very often requires the solver to reason with
% \textit{arithmetic constraints}, that is, expressions that set conditions on the values of variables
% according to arithmetic relationships and logical operators. These expressions also include quantifiers
% binding the variables.
%
While solving such constraints is already complex, an additional challenge emerges in generating
formal proofs that verify the correctness of the solutions.
%
For constraints which do not involve multiplication of variables there are established techniques
that both solve the constraints and produce proofs of correctness with high reliability.
%
The standard strategy in this case is to use a decision procedure based on the simplex method~\cite{simplex_dpllt}, which can either produce a valuation for the variables if the formula
is satisfiable, or the Farkas' coefficients~\cite{farkas_ref} otherwise.
%
These coefficients have the property of producing a constraint that is impossible to satisfy
($1 < 0$, for instance) when they are used to scale the original constraints and the resulting
expressions are added together.
%
If the original formula is unsatisfiable, the Farkas' lemma guarantee that such coefficients always
exist, thus, they can be safely used to build a proof showing that there is no solution for the problem.

However, when we extend to constraints that permit multiplication of variables,
the situation becomes substantially more difficult.
If variables ranging over integers are allowed, the problem is undecidable~\cite{integerUndec},
Otherwise, the most efficient approach is to use an algorithm based on the Cylindrical
Algebraic Decomposition (CAD)~\cite{col75},
which requires an enormous amount of computational power to be constructed. Even though
this approach has been successful in handling non-linear constraints, there is currently
no comprehensive framework for generating verifiable proofs of its results. This gap presents
a significant limitation, as non-linear reasoning is essential both for verification of
software and for formalization of mathematics.

\subsection{Goals}

The goal of this project is to bridge this gap by modifying the CAD algorithm to provide
proofs of correctness, advancing the reach and reliability of automated theorem proving
for non-linear arithmetic. Once the algorithm is designed, the next goals
are to integrate it in the Lean~\cite{lean4} proof assistant and in the cvc5~\cite{cvc5} SMT solver.
The latter is a good fit for our project since its architecture was already adapted to support proof production~\cite{flexibleProofs}.

\section{Methodology}

In order to modify an algorithm to produce proofs, it is necessary to understand the logic behind
each of its details. Thus, the first step of this project will be to study in depth the
theory behind the Cylindrical Algebraic Decomposition. This will be achieved by reading of books in the topic,
such as~\cite{computerAlgebraBook}, reading documentations of open-source systems that use this
algorithm, such as SageMath~\cite{sage} and discussing with researchers that have worked with it in the past.
The latter will be facilitated by the fact that the execution of this project will be supported by the
development team of cvc5.

Next, the existing implementations of the algorithm will be compared, and the most suitable one for the
first prototype will be identified. In principle, we beleive that the Cylindrical Algebraic
Coverings~\cite{coverings}, which only deals with formulas where all variables are existentially quantified,
would be a good fit, since it is considerably simpler than CAD while still being suitable for SMT solving. Additionally, there has been
some work~\cite{proofsCac} suggesting that this could be indeed a simpler task and
outlining some possible directions for executing it.

The next milestone will be to implement a prototype. For that, we have to define a set of proof steps
that comprehend the logical reasoning behind the algorithm. On one hand, it is important that
these proof steps aren't too coarse-grained, in the sense that it should not be hard for a program to check a particular application
of one of these proof steps;
on the other hand, they still need to be expressive enough to explain why the algorithm made a specific decision.
We will use as a baseline the description of the proof rules that cvc5 uses for its algorithms~\footnote{Which can be found at: \href{https://cvc5.github.io/docs/cvc5-1.0.0/proofs/proof\_rules.html}{https://cvc5.github.io/docs/cvc5-1.0.0/proofs/proof\_rules.html}}.
After that, we will implement a new version of the algorithm that effectively constructs a proof with these rules during its execution.

Once the algorithm is completed, we will integrate it in the Lean proof assistant by implementing, within its framework,
each one of the defined proof rules. This implementation permits us to parse and reconstruct proofs generated by the algorithm
in Lean, in a way that enables the proof assistant to recognize the unsatisfatibility of the
original non-linear problem as a theorem. This step will also validate whether the set of proof
rules we defined is appropriate or not: if they are too coarse-grained, it will be very hard to implement them
in Lean, thus we would have to redesign them.

Finally, we will integrate the algorithm in the SMT solver cvc5. Since cvc5 already has a (non-proof producing) solver for non-linear arithmetic,
it should not be hard to replace their module by our algorithm. Once this is done, we will adapt the algorithm to fit into cvc5's proof production
architecture.
% Internally, an SMT solver
% consists of a solver for SAT and multiple domain-specific solvers, one for each domain of
% interest.




% \tom{From here is just a draft}
% To enable an SMT solver to generate proofs, it is sufficient to instrument each of its internal solvers to produce proofs.
% There has been a lot of effort in the past (citations) to add this capability to the solvers. While we undertand
% how to do this for most of them, we currently don't have a good solution when it comes to non-linear arithmetic.
% There have been versions of incomplete algorithms that produce proofs for this domain (citations), but the Cylindrical Algebraic
% Decomposition, which is the main complete algorithm does not have that.

\section{Related Work}



% \subsection{Certified Virtual Substitution}

% \subsection{Integrating CAD in SMT}


\section{Schedule}
% \qquad The following table shows the plan of courses to be taken in each
% semester:

% \begin{table}[!htbp]
% \caption[Schedule]{Initial Schedule of Classes}
% \vspace{5pt}
% \centering
% \renewcommand{\arraystretch}{1.2}
% \begin{tabular}{@{}p{2cm}p{14cm}@{}}
% \toprule
% \textbf{Semester} & \textbf{Classes} \\
% \midrule
% 2021/02
%    & DCC874: Language Theory \\
%    & DCC865: Algorithm Design and Analysis\\
% \hline
% 2022/01
%    & DCC831: Formal Methods \\
%    & DCC880: Formal Semantics \\
% \hline
% 2022/02 & DCC831: Informational Theory \\
%   & DCC831: Theoretical Cryptography \\

%  \bottomrule
% \end{tabular}
% \end{table}

% \, The next table presents the planning of activities that will be
% performed per semester related to the
% project development:

% \begin{table}[!htbp]
% \caption[Schedule]{Initial Schedule of the Project}
% \vspace{5pt}
% \centering
% \renewcommand{\arraystretch}{1.2}
% \begin{tabular}{@{}p{2cm}p{14cm}@{}}
% \toprule
% \textbf{Semester} & \textbf{Goals} \\
% \midrule
%  2021/02 & Understand the operation of existing tools that integrate SMT solvers
%     with proof assistants. \\
% \hline
%  2022/01
%    & Start the implementation of the tool. \\
% \hline
%   2022/02 & Finish the implementation of the tool and start the writing of the final
%     report. \\
% \hline
%   2023/01 & Finish the writing of the final report. \\

%  \bottomrule
% \end{tabular}
% \end{table}


%\begin{figure}[h!]
%\centering
%\includegraphics[scale=1.7]{universe}
%\caption{The Universe}
%\label{fig:universe}
%\end{figure}

\renewcommand{\refname}{References}
\bibliographystyle{plain}
\bibliography{references}
\end{document}
